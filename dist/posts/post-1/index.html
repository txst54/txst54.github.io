<!DOCTYPE html><html lang="en"> <head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="viewport" content="width=device-width"><meta name="generator" content="Astro v4.0.4"><title>Raster-Based Reference Finding</title><link rel="stylesheet" href="/users/clintw/_astro/index.JlRFXkY4.css" />
<style>h1{padding-bottom:1rem;padding-top:2rem;font-family:Times New Roman;font-size:2.25rem;line-height:2.5rem;text-transform:lowercase}h2{padding-bottom:1rem;padding-top:3rem;font-size:1.5rem;line-height:2rem}article p{max-width:56rem;-webkit-hyphens:auto;hyphens:auto;padding-left:2rem;text-indent:3rem;font-size:1.125rem;line-height:1.75rem;line-height:1.625}article a{text-decoration-line:underline}
</style>
<link rel="stylesheet" href="/users/clintw/_astro/post-2.RQBSWBje.css" /></head> <body> <header> <nav class="py-2 flex justify-between"> <div class="w-10"></div> <div class="flex"> <a href="./" class="font-logo text-8xl px-8">C</a> <a href="./posts/site" class="p-6 px-28 text-2xl border-b">site</a> <a href="./links" class="p-6 px-28 text-2xl border-b">links</a> <a href="./posts" class="p-6 px-28 text-2xl border-b">posts</a> <div class="px-8"></div> </div> <button id="themeToggle" class="px-10" data-astro-cid-oemx5le4> <svg width="30px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-astro-cid-oemx5le4> <path class="sun" fill-rule="evenodd" d="M12 17.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zm0 1.5a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm12-7a.8.8 0 0 1-.8.8h-2.4a.8.8 0 0 1 0-1.6h2.4a.8.8 0 0 1 .8.8zM4 12a.8.8 0 0 1-.8.8H.8a.8.8 0 0 1 0-1.6h2.5a.8.8 0 0 1 .8.8zm16.5-8.5a.8.8 0 0 1 0 1l-1.8 1.8a.8.8 0 0 1-1-1l1.7-1.8a.8.8 0 0 1 1 0zM6.3 17.7a.8.8 0 0 1 0 1l-1.7 1.8a.8.8 0 1 1-1-1l1.7-1.8a.8.8 0 0 1 1 0zM12 0a.8.8 0 0 1 .8.8v2.5a.8.8 0 0 1-1.6 0V.8A.8.8 0 0 1 12 0zm0 20a.8.8 0 0 1 .8.8v2.4a.8.8 0 0 1-1.6 0v-2.4a.8.8 0 0 1 .8-.8zM3.5 3.5a.8.8 0 0 1 1 0l1.8 1.8a.8.8 0 1 1-1 1L3.5 4.6a.8.8 0 0 1 0-1zm14.2 14.2a.8.8 0 0 1 1 0l1.8 1.7a.8.8 0 0 1-1 1l-1.8-1.7a.8.8 0 0 1 0-1z" data-astro-cid-oemx5le4></path> <path class="moon" fill-rule="evenodd" d="M16.5 6A10.5 10.5 0 0 1 4.7 16.4 8.5 8.5 0 1 0 16.4 4.7l.1 1.3zm-1.7-2a9 9 0 0 1 .2 2 9 9 0 0 1-11 8.8 9.4 9.4 0 0 1-.8-.3c-.4 0-.8.3-.7.7a10 10 0 0 0 .3.8 10 10 0 0 0 9.2 6 10 10 0 0 0 4-19.2 9.7 9.7 0 0 0-.9-.3c-.3-.1-.7.3-.6.7a9 9 0 0 1 .3.8z" data-astro-cid-oemx5le4></path> </svg> </button>  <script>
    const theme = (() => {
      if (typeof localStorage !== 'undefined' && localStorage.getItem('theme')) {
        return localStorage.getItem('theme');
      }
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark';
      }
        return 'light';
    })();
  
    if (theme === 'light') {
      document.documentElement.classList.remove('dark');
    } else {
      document.documentElement.classList.add('dark');
    }
  
    window.localStorage.setItem('theme', theme);
  
    const handleToggleClick = () => {
      const element = document.documentElement;
      element.classList.toggle("dark");
  
      const isDark = element.classList.contains("dark");
      localStorage.setItem("theme", isDark ? "dark" : "light");
    }
  
    document.getElementById("themeToggle").addEventListener("click", handleToggleClick);
  </script> </nav> </header> <div class="flex flex-col items-center"> <h1 class="font-title text-5xl pb-10 lowercase">Raster-Based Reference Finding</h1> <div class="min-h-screen w-1/2">  <p class="text-lg flex justify-center italic pb-4">Calculating the starting reference folds from a raster crease pattern image. </p> <div class="tags flex justify-center pb-4"> <p class="italic pb-4 px-2">2023-12-10</p> <p>*</p> <p class="italic underline px-2"> <a href="/tags/origami">origami</a> </p><p>*</p><p class="italic underline px-2"> <a href="/tags/algorithms">algorithms</a> </p><p>*</p><p class="italic underline px-2"> <a href="/tags/graphics">graphics</a> </p><p>*</p><p class="italic underline px-2"> <a href="/tags/computer vision">computer vision</a> </p><p>*</p> </div> <article> <p>Identifying starting reference folds from a <a href="https://en.wikipedia.org/wiki/Crease_pattern">crease pattern</a> is one of
the most crucial skills for figurative origami folders. It is also one of the most difficult tasks for beginner folders
to grasp, especially when moving from origami designs based on angles of 45° to 22.5°. Once starting reference
folds are located, folders can perform a <a href="https://en.wikipedia.org/wiki/Breadth-first_search">level-order traversal</a>
of folds to pre-crease the model. My goal was to automate the process of locating starting reference folds from a
<a href="https://en.wikipedia.org/wiki/Raster_graphics">raster</a> crease pattern image. The code for a web-app demo of this
algorithm can be found on <a href="https://github.com/hunger-cp/img2cp">Github</a>.</p>
<h1 id="corner-detection">Corner Detection</h1>
<p>The first task was to identify vertices and lines in the crease pattern image. I tested a variety of corner and
edge detection algorithms. Most corner and edge detection algorithms had unsuitable results.
The most accurate algorithms in regard to crease patterns were the <a href="https://en.wikipedia.org/wiki/Hough_transform">Hough Line Transform</a>
and the <a href="https://users.cs.duke.edu/~tomasi/papers/shi/TR_93-1399_Cornell.pdf">Shi-Tomasi</a> corner detection algorithm.
Hough Line Transform was ultimately unsuited for crease pattern line detection as lines in crease patterns scale
to very small ratios in comparison to the lines used to model paper edges. The Hough Line Transform ranks
possible line candidates by votes that exceed a threshold. Due to the scalability
of crease pattern lines, there is no sufficient threshold that exists.
<img src="/users/clintw/_astro/shi-tomasi-corner.DPIBxFFr_ZWoXvM.webp" alt="Shi-Tomasi on a Crease Pattern" title="Shi Tomasi on a Crease Pattern" width="972" height="848" loading="lazy" decoding="async">
<center>Shi-Tomasi on a crease pattern</center></p>
<p>One significant issue with Shi-Tomasi however, was the detection of multiple corners on  the same vertex.
For this reason, along with the scalability error of crease pattern images, I chose not to use a mathematically pure
approach to this problem.</p>
<h1 id="reverse-kamiya-reference-finder">Reverse Kamiya Reference Finder</h1>
<p>The second task was to find two reference lines that intersect at any given point in the crease pattern.
Satoshi Kamiya has a nice 22.5° based reference finder on his <a href="https://folders.jp/reference/reference">website</a>. He
wrote about the mathematical process in <a href="https://www.giladorigami.com/BO_Tanteidan_Magazine_115.html">Tanteidan Magazine 115</a>.
The reference finder takes a length in the form of <span class=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">a+b\sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1328em;"></span><span class="mord mathnormal">b</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9072em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.8672em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1328em;"><span></span></span></span></span></span></span></span></span></span> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.css" integrity="sha384-WsHMgfkABRyG494OmuiNmkAOk8nhO1qE+Y6wns6v+EoNoTNxrWxYpl5ZYWFOLPCM" crossorigin="anonymous"> and calculates reference folds
that divide paper into a ratio that involves the length. It then renders the folding sequence by combining images of
reference lines, such that the intersection of the reference lines aligns with the ratio. When I began to work on the project
I thought of taking ratios of the points and deriving a ratio in the form of <span class=""><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><msqrt><mn>2</mn></msqrt></mrow><annotation encoding="application/x-tex">a+b\sqrt{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.1328em;"></span><span class="mord mathnormal">b</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9072em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span></span></span><span style="top:-2.8672em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1328em;"><span></span></span></span></span></span></span></span></span></span> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.css" integrity="sha384-WsHMgfkABRyG494OmuiNmkAOk8nhO1qE+Y6wns6v+EoNoTNxrWxYpl5ZYWFOLPCM" crossorigin="anonymous"> so that
the user could plug it into Kamiya’s Reference Finder. As mentioned earlier however, the scaling error proved far to great
to accurately derive a ratio.</p>
<p>This forced me to work backwards, reversing Kamiya’s Reference Finder process. I exported the reference folds from Kamiya’s
site and used the Hough Line Transform to vectorize the raster images of reference folds, as there was only one necessary
line to identify. The vectorized values were stored in a file so they do not have to be recomputed. All possible reference
folds for 22.5° models have now been stored. Next, the algorithm would need to locate a point in the crease pattern
that shares the same ratio as the intersection of any two reference folds. I chose a brute-force approach by calculating
all 3,000 intersections between any 2 Kamiya reference folds. The algorithm then scales the intersection coordinates
from a [0, 1] plane to a plane the size of the image and compares it with all detected vertices, picking the one with least
error.</p>
<h1 id="optimization">Optimization</h1>
<p>I shared my results online in the <a href="https://disboard.org/server/553401275127955476">Origami-Dan Discord</a>. <a href="http://jasonku.mit.edu/">Jason Ku</a>
was kind enough to give me some tips on optimization. He advised to pre-compute the 3,000 intersections and store the coordinates
in a data-structure reducing time complexity that came with recalculating the intersections.</p>
<h1 id="other-applications">Other Applications</h1>
<p>Finding a starting reference point also gives a perfect vertex for algorithmically solving a crease pattern. When the starting vertex
is identified, a level-order traversal can be run to locate all other vertices and remove error from the edge detection.</p>
<p>Another application is diagram generation for precreasing. If the folds for the starting reference point can be found, they can be
drawn into instructional diagrams. If the above algorithm was realized, folds could be calculated for all other vertices and consequently
be drawn into instructional diagram steps as well, automating the tedious process of diagram drawing.</p> </article>  </div> </div> <footer> <p>C</p> </footer> </body></html>